<html>

<script type="text/jscript">
    (function main() {
        // Create enabled event
        function fireEnabledEvent() {
            // If gli exists, then we are already present and shouldn't do anything
            if (!window.gli) {
                setTimeout(function() {
                    var enabledEvent = document.createEvent("Event");
                    enabledEvent.initEvent("WebGLEnabledEvent", true, true);
                    document.dispatchEvent(enabledEvent);
                }, 0);
            }
            else {
            }
        };

        // Grab the path root from the extension
        document.addEventListener("WebGLInspectorReadyEvent", function(e) {
            var pathElement = document.getElementById("__webglpathroot");
            if (window["gliloader"]) {
                gliloader.pathRoot = pathElement.innerText;
            } else {
                // TODO: more?
                window.gliCssUrl = pathElement.innerText + "gli.all.css";
            }
        }, false);

        // Rewrite getContext to snoop for webgl
        var originalGetContext = HTMLCanvasElement.prototype.getContext;
        if (!HTMLCanvasElement.prototype.getContextRaw) {
            HTMLCanvasElement.prototype.getContextRaw = originalGetContext;
        }
        HTMLCanvasElement.prototype.getContext = function() {
            var ignoreCanvas = this.internalInspectorSurface;
            if (ignoreCanvas) {
                return originalGetContext.apply(this, arguments);
            }

            var result = originalGetContext.apply(this, arguments);
            if (result == null) {
                return null;
            }

            var contextNames = ["moz-webgl", "webkit-3d", "experimental-webgl", "webgl", "3d"];
            var requestingWebGL = contextNames.indexOf(arguments[0]) != -1;
            if (requestingWebGL) {
                // Page is requesting a WebGL context!
                fireEnabledEvent(this);

                // If we are injected, inspect this context
                if (window.gli) {
                    if (gli.host.inspectContext) {
                        // TODO: pull options from extension
                        result = gli.host.inspectContext(this, result);
                        var hostUI = new gli.host.HostUI(result);
                        result.hostUI = hostUI; // just so we can access it later for debugging
                    }
                }
            }

            return result;
        };
    })();
    </script>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
    <title>TreeDiM StackBuilder</title>

    <script type="text/javascript" src="./glge-compiled-min.js"></script>

    <style type="text/css">
        body
        {
            margin: 0px;
        }
        #header
        {
            height: 100px;
            width: 100%;
            position: absolute;
            top: 0px;
            left: 0px;
        }
        #title
        {
            height: 40px;
            padding-left: 10px;
            background-color: rgba(0,0,0,0.5);
            color: #333;
            text-align: left;
            font-family: arial;
            -moz-box-shadow: 0px 2px 5px #333;
            -webkit-box-shadow: 0px 2px 5px #333;
            box-shadow: 0px 2px 5px #333;
        }
        #title p
        {
            float: right;
            font-size: 12px;
            color: #000;
            padding-right: 20px;
            text-shadow: 0px 1px 0px #aaa;
        }
        h1, h2
        {
            margin: 0;
            font0family: arial;
        }
        h1 small
        {
            font-size: 14px;
        }
        a
        {
            text-decoration: none;
            color: #154212;
        }
        h1
        {
            padding-top: 5px;
            font-size: 24px;
        }
    </style>
</head>
<body>
    <canvas id="canvas" width="1497" height="846" style="cursor: default;">

</canvas>
    <div id="header">
        <div id="title">
            <p>
                <b>Instructions:</b> Use left drag and mouse wheel to change view.</p>
            <h1>
                Generated by TreeDiM StackBuilder<small>Powered By <a href="http://glge.org/">GLGE</a></small></h1>
        </div>
        <div id="debug">
        </div>

        <script id="glge_document" type="text/xml">
	<glge>
		<mesh id="groundMesh">
			<positions>1.000,1.000,0.000,-1.000,1.000,0.000,-1.000,-1.000,0.000,1.000,1.000,0.000,-1.000,-1.000,0.000,1.000,-1.000,0.000</positions>
			<normals>-0.000,0.000,1.000,-0.000,0.000,1.000,-0.000,0.000,1.000,0.000,-0.000,1.000,0.000,-0.000,1.000,0.000,-0.000,1.000</normals>;
			<uv1>0.000,0.000,1.000,0.000,1.000,1.000,0.000,0.000,1.000,1.000,0.000,1.000</uv1>
			<faces>0,1,2,3,4,5,</faces>
		</mesh>
	
		<material id="lines" specular="0" color="#777" shadeless="1" />

		<scene id="mainscene" ambient_color="#333" background_color="#888" fog_type="FOG_NONE" camera="#mainCamera">
			<group id="cameraOffset">
				    <camera id="mainCamera" loc_z="20" loc_y="2.2" loc_x="0" rot_x="0" rot_y="0" />
			</group>
			
		    <collada id="colladaModel" document="test.dae" rot_x="0.0" rot_y="0.0" rot_z="0.0" loc_y="0.0" loc_z="0.0" scale="0.01" />
		    
			<light id="light1" loc_x="0" loc_y="0" loc_z="0" rot_x="0.0" rot_y="0.0" rot_z="0.0" attenuation_constant="0" type="L_DIR" />
			<light id="light2" loc_x="0" loc_y="0" loc_z="0" rot_x="0.0" rot_y="3.14" rot_z="0.0" attenuation_constant="0" type="L_DIR"/>
			<light id="light3" loc_x="0" loc_y="0" loc_z="0" rot_x="0.0" rot_y="1.57"  rot_z="0.0" attenuation_constant="0" type="L_DIR"/>
			<light id="light4" loc_x="0" loc_y="0" loc_z="0" rot_x="0.0" rot_y="-1.57" rot_z="0.0" attenuation_constant="0" type="L_DIR"/>
			<light id="light5" loc_x="0" loc_y="0" loc_z="0" rot_x="1.57" rot_y="0.0"  rot_z="0.0" attenuation_constant="0" type="L_DIR"/>
			<light id="light6" loc_x="0" loc_y="0" loc_z="0" rot_x="-1.57" rot_y="0.0" rot_z="0.0" attenuation_constant="0" type="L_DIR"/>
		</scene>
	</glge>
</script>
<script type="text/jscript">
    GLGE.DEBUGCOORD0 = false;

    var lookAt = function(origin, point) {
        var coord = [origin[0] - point[0], origin[1] - point[1], origin[2] - point[2]];
        var zvec = GLGE.toUnitVec3(coord);
        var xvec = GLGE.toUnitVec3(GLGE.crossVec3([0, 1, 0], zvec));
        var yvec = GLGE.toUnitVec3(GLGE.crossVec3(zvec, xvec));
        return [xvec[0], yvec[0], zvec[0], 0,
			xvec[1], yvec[1], zvec[1], 0,
			xvec[2], yvec[2], zvec[2], 0,
			0, 0, 0, 1];
    }

    var canvas = document.getElementById('canvas');
    canvas.width = innerWidth;
    canvas.height = innerHeight;


    var drag = false;
    var view = false;
    var rotY = 0;
    var startpoint;
    var cameraPos = [20, 10, 40];
    var mousePos = [0, 0];
    var mousestate = 0;
    var mousechange = false;
    canvas.onmousedown = function(e) {
        mousechange = true;
        mousestate = 1;
        if (e.button == 0) {
            view = true;
            startpoint = [e.clientX, e.clientY, cameraPos[0], cameraPos[1]];
        }
        e.preventDefault();
    }
    canvas.onmouseup = function(e) {
        mousechange = true;
        mousestate = 0;
        view = false;
    }
    canvas.onmousemove = function(e) {
        mousechange = true;
        mousePos = [e.clientX, e.clientY];
        if (view) {
            cameraPos[0] = startpoint[2] - (e.clientX - startpoint[0]) / canvas.width * 20;
            cameraPos[1] = startpoint[3] + (e.clientY - startpoint[1]) / canvas.height * 20;

            camera.setRotMatrix(lookAt([0, cameraPos[1], 0], [0, 0, -cameraPos[2]]));
            cameraOffset.setRotY(cameraPos[0] / 10);
            cameraOffset.setLocY(cameraPos[1]);
            render = true;
        }
    }
    canvas.onmousewheel = function(e) {
        var wheelData = e.detail ? e.detail / 10 : e.wheelDelta / -300;
        cameraPos[2] += wheelData;
        if (cameraPos[2] < 1 && cameraPos[2] > -1) cameraPos[2] = cameraPos[2] / Math.abs(cameraPos[2]);
        camera.setLocZ(cameraPos[2]);
        camera.setRotMatrix(lookAt([0, cameraPos[1], 0], [0, 0, -cameraPos[2]]));
        render = true;
    }
    canvas.addEventListener('DOMMouseScroll', canvas.onmousewheel, false);


    canvas.oncontextmenu = function(e) {
        return false;
    }

    var renderer = new GLGE.Renderer(canvas);

    var XMLdoc = new GLGE.Document();
    var camera;
    var cameraOffset;
    var scene;
    var now;
    var model;

    XMLdoc.onLoad = function() {
        scene = XMLdoc.getElement("mainscene");
        camera = XMLdoc.getElement("mainCamera");
        cameraOffset = XMLdoc.getElement("cameraOffset");
        model = XMLdoc.getElement("colladaModel");

        camera.setRotMatrix(lookAt([0, cameraPos[1], 0], [0, 0, -cameraPos[2]]));
        cameraOffset.setRotY(cameraPos[0] / 10);
        cameraOffset.setLocY(cameraPos[1]);

        var selectedObject;
        var selectObject = function(obj) {
        }

        //when model loaded get animations
        model.addEventListener("loaded", function(data) {
            selectObject(this);
        });

        var selectstart = null;


        renderer.setScene(scene);
        renderer.render();
        var lasttime;
        var render = function() {
            var now = +new Date;
            renderer.render();

            lasttime = now;
            requestAnimationFrame(render);
        };
        requestAnimationFrame(render);
    }

    XMLdoc.parseScript("glge_document");
</script>
</body>
</html>
